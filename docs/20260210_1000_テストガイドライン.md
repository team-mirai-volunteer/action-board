# テストガイドライン

このドキュメントは、action-boardプロジェクトにおけるテストの書き方・運用方法をまとめたガイドラインです。

## テストの種類と構成

プロジェクトでは4種類のテストを運用しています。

| 種類 | ディレクトリ | 実行環境 | 実行コマンド | 用途 |
|------|------------|----------|-------------|------|
| ユニットテスト | `tests/unit/` | jsdom | `pnpm run test:unit` | 純粋関数・ユーティリティのテスト |
| RLS/DBファンクションテスト | `tests/supabase/` | Node.js | `pnpm run test:supabase` | RLSポリシー・SQL関数の検証 |
| 統合テスト | `tests/integration/` | Node.js | `pnpm run test:integration` | ユースケース層のシナリオテスト |
| E2Eテスト | `tests/e2e/` | Playwright | `pnpm run test:e2e` | ブラウザ上のユーザーフロー検証 |

```
tests/
├── unit/                 # ユニットテスト
├── supabase/
│   ├── rls/              # RLSポリシーテスト
│   ├── db_function/      # DBファンクションテスト
│   └── utils.ts          # Supabaseテスト共通ユーティリティ
├── integration/          # 統合テスト（ユースケース層）
│   ├── utils.ts          # 統合テスト共通ユーティリティ
│   └── fake-line-api-client.ts  # FakeLineApiClient
├── e2e/                  # Playwright E2Eテスト
├── validation/           # スキーマ・バリデーションテスト
└── __mocks__/            # Jestモック
```

## CI実行フロー

PRが作成されると、以下のジョブが**並列実行**されます。

```
PR Created
  ├── unit_test.yaml         → pnpm run test:ci:unit（ユニットテスト + カバレッジ → Codecov）
  ├── check_code.yaml        → biome ci . + pnpm run typecheck
  ├── supabase_integration_test.yaml
  │   ├── supabase start（Docker）
  │   ├── pnpm run test:ci:supabase（RLS + DBファンクション）
  │   └── pnpm run test:ci:integration（統合テスト）
  └── e2e_test.yaml
      ├── supabase start + Next.js build
      └── Playwright（モバイルChrome、2ワーカー、リトライ2回）
```

全ジョブがパスするとマージ可能になります。

---

## ユニットテスト

### 対象

- 外部依存のない純粋関数（`utils/`、`services/` の一部）
- 計算ロジック、文字列処理、データ変換

### 書き方

```typescript
// tests/unit/example.test.ts
import { calculateSomething } from "@/features/xxx/utils/calculate";

describe("calculateSomething", () => {
  test("正常系: 期待値を返す", () => {
    expect(calculateSomething(10, 20)).toBe(30);
  });

  test("境界値: ゼロの場合", () => {
    expect(calculateSomething(0, 0)).toBe(0);
  });
});
```

### ポイント

- モックは最小限にする。純粋関数のテストが理想
- `jest.setup.js` で `server-only`、`next/navigation` 等は自動モック済み
- カバレッジ対象: `src/features/**/{services,actions,utils}/*.{ts,tsx}`

---

## RLS/DBファンクションテスト

### 対象

- Supabase RLSポリシー（テーブルごとのアクセス制御）
- Supabase SQL関数（ランキング計算、集計処理等）

### 前提

- ローカルSupabaseが起動していること（`supabase start`）
- シードデータが投入済みであること

### 書き方

詳細は [tests/supabase/rls/README.md](../tests/supabase/rls/README.md) を参照。

---

## 統合テスト（ユースケース層）

### 対象

- `use-cases/` のユースケース関数
- 実際のローカルSupabaseに対してDB操作を行うシナリオテスト

### 前提

- ローカルSupabaseが起動していること
- シードデータ（seasons等）が投入済みであること
- テスト実行: `pnpm run test:integration`

### テスト設計原則

#### 1. SupabaseClientをDIする

ユースケース関数は `SupabaseClient` をパラメータとして受け取る設計にする。テストでは `adminClient`（管理者権限）や `createTestUser()` で作成した認証済みクライアントを渡す。

```typescript
// ユースケース関数の定義
export async function changeEmail(
  supabase: SupabaseClient,
  input: { currentEmail: string; newEmail: string },
): Promise<ChangeEmailResult> { ... }

// テストでの呼び出し
const result = await changeEmail(testUser.client, {
  currentEmail: testUser.user.email,
  newEmail: "new@example.com",
});
```

#### 2. 外部APIはFakeで差し替える

外部APIクライアントはインターフェースを定義し、テストではFake実装を使う。

```typescript
// FakeLineApiClient: 実際のLINE APIを呼ばず、偽JWTを返す
const fakeClient = new FakeLineApiClient(lineUserId, "テスト太郎", "test@example.com");
const result = await lineLogin(adminClient, fakeClient, { ... });
```

#### 3. DB状態を必ず検証する（最重要）

**ユースケース関数の戻り値だけでなく、DBの状態を必ず検証する。** これにより、実際にデータが永続化されたことを保証する。

```typescript
// 悪い例: 戻り値だけの検証
const result = await changeEmail(testUser.client, { ... });
expect(result).toEqual({ success: true });  // これだけでは不十分

// 良い例: DB状態も検証
const result = await changeEmail(testUser.client, { ... });
expect(result).toEqual({ success: true });

const updatedUser = await getUserById(testUser.user.userId);
expect(updatedUser.email).toBe(newEmail);  // DBに反映されたことを確認
```

#### 4. エラーケースでもDB状態を検証する

エラーが返された場合に、**意図しないデータが作成されていないこと**をDBレベルで確認する。

```typescript
// エラーケース: ユーザーが作成されていないことを検証
const result = await lineLogin(adminClient, fakeClient, { ... });
expect(result.success).toBe(false);

const found = await findUserByLineId(lineUserId);
expect(found).toBeNull();  // DBにデータが残っていないことを確認
```

#### 5. メタデータの更新を検証する

既存データの更新テストでは、更新前後でタイムスタンプや値が変わっていることを確認する。

```typescript
// 1回目のログイン後のメタデータを記録
const userAfterFirst = await getUserById(first.userId);
const firstLinkedAt = userAfterFirst.user_metadata.line_linked_at;

// 2回目のログイン後にメタデータが更新されていることを検証
const userAfterSecond = await getUserById(second.userId);
expect(userAfterSecond.user_metadata.line_linked_at).not.toBe(firstLinkedAt);
```

### テストユーティリティ

#### `tests/integration/utils.ts`

| 関数 | 用途 |
|------|------|
| `adminClient` | サービスロールクライアント（RLSバイパス） |
| `createTestUser(email?, password?)` | テストユーザー作成（auth + private_users + public_user_profiles） |
| `cleanupTestUser(authId)` | テストユーザーの完全削除 |
| `getUserById(userId)` | auth.usersからユーザーを取得 |
| `findUserByLineId(lineUserId)` | LINE IDでユーザーを検索（RPC） |

#### `tests/integration/fake-line-api-client.ts`

`LineApiClient` インターフェースのFake実装。コンストラクタで渡したユーザー情報からBase64エンコードした偽JWTを生成する。`parseIdTokenPayload` でデコード可能。

```typescript
const fakeClient = new FakeLineApiClient(
  "U_test_123",     // LINE user ID
  "テスト太郎",      // 表示名
  "test@example.com", // メールアドレス（省略可）
  "https://example.com/picture.jpg", // プロフィール画像（省略可）
);
```

### テストの書き方テンプレート

```typescript
import { someUseCase } from "@/features/xxx/use-cases/some-use-case";
import { adminClient, cleanupTestUser, createTestUser, getUserById } from "./utils";

describe("someUseCase ユースケース", () => {
  // テスト後のクリーンアップ用
  const createdUserIds: string[] = [];
  // または beforeEach/afterEach で管理
  let testUser: Awaited<ReturnType<typeof createTestUser>>;

  beforeEach(async () => {
    testUser = await createTestUser();
  });

  afterEach(async () => {
    await cleanupTestUser(testUser.user.userId);
    for (const id of createdUserIds) {
      await cleanupTestUser(id);
    }
    createdUserIds.length = 0;
  });

  test("正常系: 操作が成功する", async () => {
    // 1. ユースケース実行
    const result = await someUseCase(testUser.client, { ... });
    expect(result.success).toBe(true);

    // 2. DB状態を検証
    const user = await getUserById(testUser.user.userId);
    expect(user.someField).toBe(expectedValue);
  });

  test("異常系: バリデーションエラー", async () => {
    // 1. ユースケース実行（エラーを期待）
    const result = await someUseCase(testUser.client, { invalid: true });
    expect(result.success).toBe(false);

    // 2. DB状態が変わっていないことを検証
    const user = await getUserById(testUser.user.userId);
    expect(user.someField).toBe(originalValue);
  });
});
```

---

## E2Eテスト

### 対象

- ブラウザ上のユーザーフロー（認証、ミッション操作、マップ操作等）

### 構成

- Playwright使用、モバイルChrome（Pixel 5）のみ
- `tests/e2e-test-helpers.ts` にカスタムフィクスチャ定義
  - `testUser`: テストユーザーの自動作成・削除
  - `signedInPage`: ログイン済みブラウザコンテキスト

### 実行

```bash
pnpm run test:e2e        # 通常実行
pnpm run test:e2e:ui     # UIモード（デバッグ用）
pnpm run test:e2e:debug  # デバッグモード
```

---

## テスト作成時の注意事項

### クリーンアップ

- テストで作成したデータは `afterEach` で必ず削除する
- `cleanupTestUser()` はauth + private_users + public_user_profiles を削除する
- FK cascadeが設定されていないテーブルは明示的に削除が必要

### 一意性の確保

- テストデータのメールアドレスやIDには `Date.now()` を含めて一意にする
- 並列実行時のデータ競合を防ぐ

```typescript
const email = `test-${Date.now()}@example.com`;
const lineUserId = `U_test_${Date.now()}`;
```

### 型の扱い

- テスト内で意図的に型を崩す場合は `as any` を使用してよい
- Biome警告（`noNonNullAssertion`等）はテストファイルでは許容

### CIでのflaky対策

- RLSテスト（`missions.test.ts`等）は "An invalid response was received from the upstream server" で失敗することがある → `gh run rerun <id> --failed` で再実行
- E2Eテストは2回リトライ設定済み
- 失敗時はログを確認してから再実行する（本当のバグとflakyを区別）
